-- ui variables------------
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

--- variables autofarm---

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- anti-afk
player.Idled:Connect(function()
    game:GetService("VirtualUser"):CaptureController()
    game:GetService("VirtualUser"):ClickButton2(Vector2.new())
end)

-- comprobaciÃ³n segura de leaderstats
local leaderstats = player:FindFirstChild("leaderstats")

local totalKills = 0
local monthlyKills = 0

if leaderstats then
    local totalKillsObj = leaderstats:FindFirstChild("Total Kills")
    local monthlyKillsObj = leaderstats:FindFirstChild("Kills")

    if totalKillsObj then
        totalKills = totalKillsObj.Value
    end

    if monthlyKillsObj then
        monthlyKills = monthlyKillsObj.Value
    end
end

-- crear parte para farming
local part = Instance.new("Part")
part.Anchored = true
part.Transparency = 1
part.Name = "Farming Ground"
part.Size = Vector3.new(2048, 20, 2048)
part.CFrame = CFrame.new(150, 10000, 30)
part.Parent = workspace

---- function----
local function instaKill()
    local character = player.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0
    end
end

-- anti slow function
local RunService = game:GetService("RunService")
local antiSlowEnabled = false

local function clearIfExists(obj, names)
    for _, name in ipairs(names) do
        local child = obj:FindFirstChild(name)
        if child then child:Destroy() end
        if obj:GetAttribute(name) then obj:SetAttribute(name, false) end
    end
end

player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
    humanoidRootPart = char:WaitForChild("HumanoidRootPart")
end)

RunService.RenderStepped:Connect(function()
    if antiSlowEnabled and character then
        clearIfExists(character, {"Freeze", "Slowed", "GlobalStun","NoBlock","NoJump","StopRunning","Ragdoll","RagdollSim","ComboStun","BeingGrabbed"})
    end
end)

--- script main---

local Window = Fluent:CreateWindow({
    Title = "The strongest Auto farm  V2.0",
    SubTitle = "by theyfw_lxchu and collab with Dave_Down",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Autofarm = Window:AddTab({ Title = "AutoFarm Alt", Icon = "" }),
    Autofarm2 = Window:AddTab({ Title = "AutoFarm Blatant", Icon = "" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "ðŸ‘…ðŸ‘…ðŸ‘…ðŸ‘…",
        Content = "Loading TSB Autofarm...",
        SubContent = "If only this shows contact me on discord, Dave_Down",
        Duration = 5
    })

    Tabs.Main:AddParagraph({
        Title = "TSB Autofarm",
        Content = "Welcome..  " .. character.Name
    })

    Tabs.Main:AddParagraph({
        Title = "Change log 2.0v",
        Content = "Added another method of autofarm,added anti stun,Fixed potential bugs",
    })

    Tabs.Main:AddParagraph({
        Title = "If any problems",
        Content = "Contact dave_down on discord ",
    })
    Tabs.Main:AddParagraph({
        Title = "TSB Autofarm",
        Content = "Total Kills: " .. totalKills
    })

    Tabs.Main:AddParagraph({
        Title = "TSB Autofarm",
        Content = "Monthly Kills: " .. monthlyKills
    })

    -- toggle autofarm
    local Toggle = Tabs.Autofarm:AddToggle("MyToggle", {
        Title = "Auto Farm Toggle",
        Default = false
    })

    local teleportConnection = nil

    Toggle:OnChanged(function(Value)
        print("Toggle changed:", Value)

        while task.wait(0.1) and Options.MyToggle.Value do
            if player.Backpack:FindFirstChild("Shove") then
                humanoidRootPart.CFrame = part.CFrame * CFrame.new(0, 11, 0)

                for _, tool in pairs(player.Backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        humanoid:EquipTool(tool)
                        task.wait(0.001)
                        tool:Activate()
                        humanoid:UnequipTools()
                        task.wait(0.001)
                    end
                end
            else
                humanoidRootPart.CFrame = part.CFrame * CFrame.new(0, 11, -2)
                player.CharacterAdded:Connect(function(char)
                    humanoidRootPart = char:WaitForChild("HumanoidRootPart")
                    humanoidRootPart.CFrame = part.CFrame * CFrame.new(0, 11, -2)
                end)
            end
        end

        if not Options.MyToggle.Value then
            if teleportConnection then
                teleportConnection:Disconnect()
                teleportConnection = nil
            end
        end
    end)

    Options.MyToggle:SetValue(false)



local Toggle = Tabs.Misc:AddToggle("Auto claim emote", {
    Title = "Auto claim emote ðŸ”¥ðŸ”¥ðŸ”¥",
    Default = false
})

Toggle:OnChanged(function(value)
    if value then
        task.spawn(function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()

            while Toggle.Value and task.wait(2) do -- cada 2s, ajusta si quieres
                local args = {
                    [1] = {
                        ["Goal"] = "Emote Spin"
                    }
                }

                local success, err = pcall(function()
                    workspace:WaitForChild("Live", 9e9)
                        :WaitForChild(character.Name, 9e9)
                        :WaitForChild("Communicate", 9e9)
                        :FireServer(unpack(args))
                end)

                if not success then
                    warn("Error auto claim emote:", err)
                end
            end
        end)
    end
end)

        local AntiSlowToggle = Tabs.Misc:AddToggle("AntiSlowToggle", {Title = "Anti Slow", Default = false })

    AntiSlowToggle:OnChanged(function(value)
        print("Anti Slow changed:", value)
        antiSlowEnabled = value
    end)

    Options.AntiSlowToggle:SetValue(false)
    -- noclip functions and toggle
    local NoclipConn = nil
    local Clip = true
    local floatName = nil

    local function noclip()
        Clip = false
        local function Nocl()
            if Clip == false and player.Character then
                for _, v in pairs(player.Character:GetDescendants()) do
                    if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
                        v.CanCollide = false
                    end
                end
            end
            wait(0.21)
        end
        NoclipConn = RunService.Stepped:Connect(Nocl)
    end

    local function clip()
        if NoclipConn then NoclipConn:Disconnect() NoclipConn = nil end
        Clip = true
    end

    local NoclipToggle = Tabs.Misc:AddToggle("NoclipToggle", {Title = "NoClip", Default = false})
    NoclipToggle:OnChanged(function(state)
        if state then
            noclip()
        else
            clip()
        end
    end)

    Options.NoclipToggle:SetValue(false)

    -- toggle trash thrower
    local TrashToggle = Tabs.Autofarm2:AddToggle("TrashToggle", {Title = "Trash Thrower", Default = false })

    TrashToggle:OnChanged(function(value)
        if value then
            task.spawn(function()
                while Options.TrashToggle.Value do
                    task.wait(0.6)

                    local map = workspace:FindFirstChild("Map")
                    local trashFolder = map and map:FindFirstChild("Trash")
                    if not trashFolder then
                        warn("Map.Trash not found!")
                        break
                    end

                    -- collect all trashcan candidates
                    local trashCandidates = {}
                    for _, v in ipairs(trashFolder:GetChildren()) do
                        if tostring(v.Name):lower():find("trashcan") then
                            table.insert(trashCandidates, v)
                        elseif v:FindFirstChild("Trashcan") then
                            table.insert(trashCandidates, v:FindFirstChild("Trashcan"))
                        end
                    end

                    -- fallback to index-based candidate if none found
                    if #trashCandidates == 0 and #trashFolder:GetChildren() >= 10 then
                        local candidate = trashFolder:GetChildren()[10]
                        local nested = candidate and (candidate:FindFirstChild("Trashcan") or candidate)
                        if nested then table.insert(trashCandidates, nested) end
                    end

                    if #trashCandidates == 0 then
                        warn("No Trashcan models found in Map.Trash")
                        break
                    end

                    -- iterate every trashcan and perform the sequence
                    for _, trashCanModel in ipairs(trashCandidates) do
                        if not Options.TrashToggle.Value then break end

                        local targetPart = trashCanModel:FindFirstChildWhichIsA("BasePart") or trashCanModel:FindFirstChild("Handle") or (trashCanModel:IsA("BasePart") and trashCanModel)
                        if not targetPart then
                            warn("Skipping Trashcan: no BasePart/Handle found")
                            continue
                        end

                        -- Update character references in case of respawn
                        if not character or not character.Parent then
                            character = player.Character
                        end
                        if character then
                            humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        end
                        
                        if not humanoidRootPart then
                            warn("HumanoidRootPart not found, skipping trashcan")
                            continue
                        end

                        -- TP to the side of the trashcan and face it
                        print("Teleporting to trashcan:", trashCanModel.Name)
                        local sideOffset = (targetPart.Size.X / 2) + 3
                        local sidePos = targetPart.Position + (targetPart.CFrame.RightVector * sideOffset) + Vector3.new(0, 2, 0)
                        humanoidRootPart.CFrame = CFrame.new(sidePos, targetPart.Position)
                        task.wait(0.3) -- Wait for teleport to register

                        local clickDetector = trashCanModel:FindFirstChildOfClass("ClickDetector") or targetPart:FindFirstChildOfClass("ClickDetector")
                        local prompt = trashCanModel:FindFirstChildOfClass("ProximityPrompt") or targetPart:FindFirstChildOfClass("ProximityPrompt")

                        -- ===== GRAB TRASHCAN PHASE =====
                        print("Attempting to grab trashcan...")
                        local grabbed = false

                        -- 1) Try RemoteEvent LeftClick method first (GRAB)
                        for grabAttempt = 1, 2 do
                            local success = pcall(function()
                                local args = {[1] = {["Goal"] = "LeftClick"}}
                                workspace:WaitForChild("Live", 9e9)
                                    :WaitForChild(character.Name, 9e9)
                                    :WaitForChild("Communicate", 9e9)
                                    :FireServer(unpack(args))
                                task.wait(0.08)
                                local args2 = {[1] = {["Goal"] = "LeftClickRelease"}}
                                workspace:WaitForChild("Live", 9e9)
                                    :WaitForChild(character.Name, 9e9)
                                    :WaitForChild("Communicate", 9e9)
                                    :FireServer(unpack(args2))
                            end)
                            
                            if success then
                                grabbed = true
                                print("Grabbed with LeftClick method")
                                break
                            end
                            task.wait(0.1)
                        end

                        -- 2) Try touch simulation if LeftClick didn't work
                        if not grabbed and targetPart:IsA("MeshPart") and type(firetouchinterest) == "function" and humanoidRootPart then
                            pcall(firetouchinterest, targetPart, humanoidRootPart, 0)
                            task.wait(0.08)
                            pcall(firetouchinterest, targetPart, humanoidRootPart, 1)
                            grabbed = true
                            print("Grabbed with touch simulation")
                        end

                        -- 3) Try RemoteEvent/Function on the model
                        if not grabbed then
                            for _, d in ipairs(trashCanModel:GetDescendants()) do
                                if d:IsA("RemoteEvent") then
                                    pcall(function() d:FireServer() end)
                                    grabbed = true
                                    print("Grabbed with RemoteEvent")
                                    break
                                elseif d:IsA("RemoteFunction") then
                                    pcall(function() d:InvokeServer() end)
                                    grabbed = true
                                    print("Grabbed with RemoteFunction")
                                    break
                                end
                            end
                        end

                        -- 4) Try ClickDetector
                        if not grabbed and clickDetector then
                            if type(fireclickdetector) == "function" then
                                pcall(fireclickdetector, clickDetector)
                            else
                                pcall(function() clickDetector:MouseClick(player) end)
                            end
                            grabbed = true
                            print("Grabbed with ClickDetector")
                        end

                        -- 5) Try ProximityPrompt
                        if not grabbed and prompt then
                            pcall(function() prompt:InputHoldBegin() end)
                            task.wait(0.2)
                            pcall(function() prompt:InputHoldEnd() end)
                            grabbed = true
                            print("Grabbed with ProximityPrompt")
                        end

                        -- 6) Last resort: VirtualUser screen click
                        if not grabbed then
                            local camera = workspace.CurrentCamera
                            local vu = game:GetService("VirtualUser")
                            if camera and targetPart then
                                local ok, originalCFrame = pcall(function() return camera.CFrame end)
                                local okType = pcall(function() return camera.CameraType end)
                                pcall(function()
                                    camera.CameraType = Enum.CameraType.Scriptable
                                    camera.CFrame = CFrame.new(targetPart.Position + (camera.CFrame.LookVector * -6), targetPart.Position)
                                end)
                                task.wait(0.06)
                                local viewport = nil
                                pcall(function() viewport = camera.ViewportSize end)
                                local center = viewport and Vector2.new(viewport.X / 2, viewport.Y / 2) or Vector2.new(400, 300)
                                pcall(function()
                                    vu:CaptureController()
                                    vu:ClickButton1(center)
                                end)
                                task.wait(0.18)
                                pcall(function()
                                    if okType then camera.CameraType = Enum.CameraType.Custom end
                                    if ok then camera.CFrame = originalCFrame end
                                end)
                                grabbed = true
                                print("Grabbed with VirtualUser click")
                            end
                        end

                        -- Wait after grabbing to ensure it's in hand
                        task.wait(0.5)
                        print("Grab phase complete, waiting before throw...")

                        if not Options.TrashToggle.Value then break end

                        -- pick a random valid player each iteration
                        local playersList = Players:GetPlayers()
                        local validTargets = {}
                        for _, p in ipairs(playersList) do
                            if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                table.insert(validTargets, p)
                            end
                        end

                        if #validTargets == 0 then
                            task.wait(0.5)
                            continue
                        end

                        -- ===== THROW TRASHCAN PHASE =====
                        local chosen = validTargets[math.random(1, #validTargets)]
                        local targetHRP = chosen.Character and chosen.Character:FindFirstChild("HumanoidRootPart")
                        if targetHRP then
                            -- Update character references again before throwing
                            if not character or not character.Parent then
                                character = player.Character
                            end
                            if character then
                                humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                            end
                            
                            if not humanoidRootPart then
                                warn("HumanoidRootPart not found for throw, skipping")
                                task.wait(0.5)
                                continue
                            end

                            print("Teleporting to target player:", chosen.Name)
                            
                            -- Randomly choose left or right side of the target
                            local sideDirection = math.random(0, 1) == 0 and -1 or 1
                            local sideDistance = 5 -- distance to the side
                            
                            -- Start constant teleportation loop
                            local throwConnection
                            local throwComplete = false
                            
                            throwConnection = RunService.Heartbeat:Connect(function()
                                if not Options.TrashToggle.Value or throwComplete then
                                    if throwConnection then
                                        throwConnection:Disconnect()
                                    end
                                    return
                                end
                                
                                -- Update target position constantly
                                local currentTargetHRP = chosen.Character and chosen.Character:FindFirstChild("HumanoidRootPart")
                                if currentTargetHRP and humanoidRootPart then
                                    local targetCFrame = currentTargetHRP.CFrame
                                    local sideOffset = targetCFrame.RightVector * (sideDistance * sideDirection)
                                    humanoidRootPart.CFrame = CFrame.new(currentTargetHRP.Position + sideOffset + Vector3.new(0, 2, 0), currentTargetHRP.Position)
                                end
                            end)

                            task.wait(0.4) -- Wait for initial positioning

                            print("Attempting to throw trashcan...")
                            local thrown = false

                            -- Try LeftClick method multiple times (THROW)
                            for throwAttempt = 1, 3 do
                                local throwSuccess = pcall(function()
                                    local args = {[1] = {["Goal"] = "LeftClick"}}
                                    workspace:WaitForChild("Live", 9e9)
                                        :WaitForChild(character.Name, 9e9)
                                        :WaitForChild("Communicate", 9e9)
                                        :FireServer(unpack(args))
                                    task.wait(0.08)
                                    local args2 = {[1] = {["Goal"] = "LeftClickRelease"}}
                                    workspace:WaitForChild("Live", 9e9)
                                        :WaitForChild(character.Name, 9e9)
                                        :WaitForChild("Communicate", 9e9)
                                        :FireServer(unpack(args2))
                                end)
                                
                                if throwSuccess then
                                    thrown = true
                                    print("Threw with LeftClick method (attempt " .. throwAttempt .. ")")
                                    break
                                end
                                task.wait(0.15)
                            end

                            -- Fallback to other methods if LeftClick didn't work
                            if not thrown then
                                task.wait(0.2)
                                if clickDetector then
                                    if type(fireclickdetector) == "function" then
                                        pcall(fireclickdetector, clickDetector)
                                    else
                                        pcall(function() clickDetector:MouseClick(player) end)
                                    end
                                    print("Threw with ClickDetector fallback")
                                end
                                
                                if prompt then
                                    pcall(function() prompt:InputHoldBegin() end)
                                    task.wait(0.1)
                                    pcall(function() prompt:InputHoldEnd() end)
                                    print("Threw with ProximityPrompt fallback")
                                end
                            end
                            
                            -- Stop constant teleportation
                            throwComplete = true
                            if throwConnection then
                                throwConnection:Disconnect()
                            end
                            
                            -- Delay after throwing before next trashcan
                            print("Throw complete, waiting before next trashcan...")
                            task.wait(1)
                        end

                        task.wait(0.5)
                    end

                    task.wait(1)
                end
            end)
        end
    end)

    Options.TrashToggle:SetValue(false)

    -- toggle instakill
    local InstaToggle = Tabs.Autofarm:AddToggle("InstaKillToggle", {Title = "Insta Kill (use in alt)", Default = false})

    local instaKillEnabled = false

    InstaToggle:OnChanged(function(state)
        print("InstaKill changed:", state)
        instaKillEnabled = state

        local function onCharacterAdded(character)
            local humanoid = character:WaitForChild("Humanoid")

            humanoid.HealthChanged:Connect(function(newHealth)
                if instaKillEnabled and newHealth < humanoid.MaxHealth then
                    instaKill()
                end
            end)
        end

        if player.Character then
            onCharacterAdded(player.Character)
        end

        player.CharacterAdded:Connect(onCharacterAdded)
    end)

    Options.InstaKillToggle:SetValue(false)
end


-- addons
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 8
})

SaveManager:LoadAutoloadConfig()
